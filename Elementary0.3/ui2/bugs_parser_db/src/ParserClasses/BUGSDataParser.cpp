/** \file
 *  This C++ source file was generated by $ANTLR version 3.5-rc-2
 *
 *     -  From the grammar source file : /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g
 *     -                            On : 2013-05-06 12:09:58
 *     -                for the parser : BUGSDataParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "BUGSDataParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace BUGSData {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   BUGSDataParserTokenNames[13+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "CLOSEBRACKET",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "CONSTANTVALUE",
        (ANTLR_UINT8*) "DATA",
        (ANTLR_UINT8*) "DIM",
        (ANTLR_UINT8*) "DOT",
        (ANTLR_UINT8*) "EQUALTO",
        (ANTLR_UINT8*) "LIST",
        (ANTLR_UINT8*) "NA",
        (ANTLR_UINT8*) "NODENAME",
        (ANTLR_UINT8*) "STRUCTUREBEGIN",
        (ANTLR_UINT8*) "VECTORBEGIN",
        (ANTLR_UINT8*) "WHITESPACE"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* BUGSDataParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new BUGSDataParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSDataParser::BUGSDataParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new BUGSDataParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSDataParser::BUGSDataParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void BUGSDataParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( BUGSDataParserTokenNames );


}

void
BUGSDataParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
BUGSDataParser::~BUGSDataParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return BUGSDataParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_LIST_in_data141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_LIST_in_data141( FOLLOW_LIST_in_data141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_datatype_in_data143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_datatype_in_data143( FOLLOW_datatype_in_data143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_data147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_COMMA_in_data147( FOLLOW_COMMA_in_data147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_datatype_in_data149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_datatype_in_data149( FOLLOW_datatype_in_data149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_data154_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_data154( FOLLOW_CLOSEBRACKET_in_data154_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_scalar_in_datatype170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_scalar_in_datatype170( FOLLOW_scalar_in_datatype170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_vector_in_datatype177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_vector_in_datatype177( FOLLOW_vector_in_datatype177_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_array_in_datatype184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_array_in_datatype184( FOLLOW_array_in_datatype184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_array205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NODENAME_in_array205( FOLLOW_NODENAME_in_array205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_EQUALTO_in_array207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_EQUALTO_in_array207( FOLLOW_EQUALTO_in_array207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_STRUCTUREBEGIN_in_array209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_STRUCTUREBEGIN_in_array209( FOLLOW_STRUCTUREBEGIN_in_array209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_DOT_in_array211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_DOT_in_array211( FOLLOW_DOT_in_array211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_DATA_in_array213_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_DATA_in_array213( FOLLOW_DATA_in_array213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_EQUALTO_in_array215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_EQUALTO_in_array215( FOLLOW_EQUALTO_in_array215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_vectordata_in_array219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_vectordata_in_array219( FOLLOW_vectordata_in_array219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_array221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_COMMA_in_array221( FOLLOW_COMMA_in_array221_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_DOT_in_array225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_DOT_in_array225( FOLLOW_DOT_in_array225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_DIM_in_array227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_DIM_in_array227( FOLLOW_DIM_in_array227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_EQUALTO_in_array229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_EQUALTO_in_array229( FOLLOW_EQUALTO_in_array229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_vectordata_in_array233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_vectordata_in_array233( FOLLOW_vectordata_in_array233_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_array235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_array235( FOLLOW_CLOSEBRACKET_in_array235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_vector253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NODENAME_in_vector253( FOLLOW_NODENAME_in_vector253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_EQUALTO_in_vector255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_EQUALTO_in_vector255( FOLLOW_EQUALTO_in_vector255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_vectordata_in_vector257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_vectordata_in_vector257( FOLLOW_vectordata_in_vector257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_VECTORBEGIN_in_vectordata278_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001040) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_VECTORBEGIN_in_vectordata278( FOLLOW_VECTORBEGIN_in_vectordata278_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NA_in_vectordata287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NA_in_vectordata287( FOLLOW_NA_in_vectordata287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_vectordata302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_vectordata302( FOLLOW_CONSTANTVALUE_in_vectordata302_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vectordata315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001040) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_COMMA_in_vectordata315( FOLLOW_COMMA_in_vectordata315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NA_in_vectordata325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NA_in_vectordata325( FOLLOW_NA_in_vectordata325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_vectordata340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_vectordata340( FOLLOW_CONSTANTVALUE_in_vectordata340_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_vectordata354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_vectordata354( FOLLOW_CLOSEBRACKET_in_vectordata354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_scalar371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NODENAME_in_scalar371( FOLLOW_NODENAME_in_scalar371_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_EQUALTO_in_scalar373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001040) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_EQUALTO_in_scalar373( FOLLOW_EQUALTO_in_scalar373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_NA_in_scalar381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_NA_in_scalar381( FOLLOW_NA_in_scalar381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSDataParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_scalar391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSDataParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_scalar391( FOLLOW_CONSTANTVALUE_in_scalar391_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start data
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:39:1: data[MainMemoryData* mmdata] : LIST datatype[mmdata] ( COMMA datatype[mmdata] )* CLOSEBRACKET ;
 */
void
BUGSDataParser::data(MainMemoryData* mmdata)
{
        BUGSDataParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:40:2: ( LIST datatype[mmdata] ( COMMA datatype[mmdata] )* CLOSEBRACKET )
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:40:4: LIST datatype[mmdata] ( COMMA datatype[mmdata] )* CLOSEBRACKET
        {
             this->matchToken(LIST, &FOLLOW_LIST_in_data141);
            if  (this->hasException())
            {
                goto ruledataEx;
            }


            this->followPush(FOLLOW_datatype_in_data143);
            datatype(mmdata);

            this->followPop();
            if  (this->hasException())
            {
                goto ruledataEx;
            }


            // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:40:26: ( COMMA datatype[mmdata] )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:40:27: COMMA datatype[mmdata]
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_data147);
            	        if  (this->hasException())
            	        {
            	            goto ruledataEx;
            	        }


            	        this->followPush(FOLLOW_datatype_in_data149);
            	        datatype(mmdata);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledataEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_data154);
            if  (this->hasException())
            {
                goto ruledataEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledataEx; /* Prevent compiler warnings */
    ruledataEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end data */

/**
 * $ANTLR start datatype
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:43:1: datatype[MainMemoryData* mmdata] : ( scalar | vector | array );
 */
void
BUGSDataParser::datatype(MainMemoryData* mmdata)
{
        BUGSDataParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    BUGSDataParser_scalar_return scalar1;
    typedef	BUGSDataParser_scalar_return RETURN_TYPE_scalar1;

    BUGSDataParser_vector_return vector2;
    typedef	BUGSDataParser_vector_return RETURN_TYPE_vector2;

    BUGSDataParser_array_return array3;
    typedef	BUGSDataParser_array_return RETURN_TYPE_array3;

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:44:2: ( scalar | vector | array )

            ANTLR_UINT32 alt2;

            alt2=3;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case EQUALTO:
            			{
            				switch ( this->LA(3) )
            				{
            				case STRUCTUREBEGIN:
            					{
            						alt2=3;
            					}
            				    break;
            				case CONSTANTVALUE:
            				case NA:
            					{
            						alt2=1;
            					}
            				    break;
            				case VECTORBEGIN:
            					{
            						alt2=2;
            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 2 );
            				    ex->set_state( 2 );


            				    goto ruledatatypeEx;

            				}

            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto ruledatatypeEx;

            		}

            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto ruledatatypeEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:44:4: scalar
        	    {
        	        this->followPush(FOLLOW_scalar_in_datatype170);
        	        scalar1=scalar();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }


        	        {
        	            mmdata->scalars[scalar1.nodename
        	            ] = scalar1.value
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:45:4: vector
        	    {
        	        this->followPush(FOLLOW_vector_in_datatype177);
        	        vector2=vector();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }


        	        {
        	            mmdata->NAlocations[vector2.nodename
        	            ] = vector2.NAlocations
        	            ; mmdata->vectors[vector2.nodename
        	            ] = vector2.value
        	            ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:46:4: array
        	    {
        	        this->followPush(FOLLOW_array_in_datatype184);
        	        array3=array();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }


        	        {
        	             BugsArray* bugsarray = new BugsArray();
        	            	bugsarray->data=array3.value
        	            ;
        	            	bugsarray->NAlocations =array3.NAlocations
        	            ;
        	            	bugsarray->dimensions=array3.dimensions
        	            ;
        	            	mmdata->array[array3.nodename
        	            ]= bugsarray; 
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledatatypeEx; /* Prevent compiler warnings */
    ruledatatypeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end datatype */

/**
 * $ANTLR start array
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:54:1: array returns [std::string nodename, std::deque<double> value, std::unordered_set<int> NAlocations, std::deque<double> dimensions] : NODENAME EQUALTO STRUCTUREBEGIN DOT DATA EQUALTO v1= vectordata COMMA DOT DIM EQUALTO v2= vectordata CLOSEBRACKET ;
 */
BUGSDataParser_array_return
BUGSDataParser::array()
{
    BUGSDataParser_array_return retval(this);


    const CommonTokenType*    NODENAME4;
    BUGSDataParser_vectordata_return v1;
    typedef	BUGSDataParser_vectordata_return RETURN_TYPE_v1;

    BUGSDataParser_vectordata_return v2;
    typedef	BUGSDataParser_vectordata_return RETURN_TYPE_v2;

    /* Initialize rule variables
     */

    NODENAME4       = NULL;
    retval.call_start_placeholder(); 



 
    {
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:55:2: ( NODENAME EQUALTO STRUCTUREBEGIN DOT DATA EQUALTO v1= vectordata COMMA DOT DIM EQUALTO v2= vectordata CLOSEBRACKET )
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:55:4: NODENAME EQUALTO STRUCTUREBEGIN DOT DATA EQUALTO v1= vectordata COMMA DOT DIM EQUALTO v2= vectordata CLOSEBRACKET
        {
            NODENAME4 =  this->matchToken(NODENAME, &FOLLOW_NODENAME_in_array205);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(EQUALTO, &FOLLOW_EQUALTO_in_array207);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(STRUCTUREBEGIN, &FOLLOW_STRUCTUREBEGIN_in_array209);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(DOT, &FOLLOW_DOT_in_array211);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(DATA, &FOLLOW_DATA_in_array213);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(EQUALTO, &FOLLOW_EQUALTO_in_array215);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


            this->followPush(FOLLOW_vectordata_in_array219);
            v1=vectordata();

            this->followPop();
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_array221);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(DOT, &FOLLOW_DOT_in_array225);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(DIM, &FOLLOW_DIM_in_array227);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(EQUALTO, &FOLLOW_EQUALTO_in_array229);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


            this->followPush(FOLLOW_vectordata_in_array233);
            v2=vectordata();

            this->followPop();
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_array235);
            if  (this->hasException())
            {
                goto rulearrayEx;
            }


            {
                retval.nodename= (NODENAME4->getText());
                 retval.value=
                v1.value
                ;
                 retval.NAlocations=
                v1.NAlocations
                ;
                 retval.dimensions=
                v2.value
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulearrayEx; /* Prevent compiler warnings */
    rulearrayEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end array */

/**
 * $ANTLR start vector
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:60:1: vector returns [std::string nodename, std::deque<double> value, std::unordered_set<int> NAlocations] : NODENAME EQUALTO vectordata ;
 */
BUGSDataParser_vector_return
BUGSDataParser::vector()
{
    BUGSDataParser_vector_return retval(this);


    const CommonTokenType*    NODENAME5;
    BUGSDataParser_vectordata_return vectordata6;
    typedef	BUGSDataParser_vectordata_return RETURN_TYPE_vectordata6;

    /* Initialize rule variables
     */

    NODENAME5       = NULL;
    retval.call_start_placeholder(); 



 
    {
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:61:2: ( NODENAME EQUALTO vectordata )
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:61:4: NODENAME EQUALTO vectordata
        {
            NODENAME5 =  this->matchToken(NODENAME, &FOLLOW_NODENAME_in_vector253);
            if  (this->hasException())
            {
                goto rulevectorEx;
            }


             this->matchToken(EQUALTO, &FOLLOW_EQUALTO_in_vector255);
            if  (this->hasException())
            {
                goto rulevectorEx;
            }


            this->followPush(FOLLOW_vectordata_in_vector257);
            vectordata6=vectordata();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevectorEx;
            }


            {
                retval.nodename= (NODENAME5->getText());
                 retval.value= 
                vectordata6.value
                ;
                 retval.NAlocations= 
                vectordata6.NAlocations
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevectorEx; /* Prevent compiler warnings */
    rulevectorEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end vector */

/**
 * $ANTLR start vectordata
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:64:1: vectordata returns [std::deque<double> value, std::unordered_set<int> NAlocations] : VECTORBEGIN (cv1= NA |cv1= CONSTANTVALUE ) ( COMMA (cv2= NA |cv2= CONSTANTVALUE ) )* CLOSEBRACKET ;
 */
BUGSDataParser_vectordata_return
BUGSDataParser::vectordata()
{
    BUGSDataParser_vectordata_return retval(this);


    const CommonTokenType*    cv1;
    const CommonTokenType*    cv2;

    /* Initialize rule variables
     */
    m_vectordata_stack.push(vectordataScope()); 
    cv1       = NULL;
    cv2       = NULL;
    retval.call_start_placeholder(); 



 
    {
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:68:2: ( VECTORBEGIN (cv1= NA |cv1= CONSTANTVALUE ) ( COMMA (cv2= NA |cv2= CONSTANTVALUE ) )* CLOSEBRACKET )
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:68:4: VECTORBEGIN (cv1= NA |cv1= CONSTANTVALUE ) ( COMMA (cv2= NA |cv2= CONSTANTVALUE ) )* CLOSEBRACKET
        {
             this->matchToken(VECTORBEGIN, &FOLLOW_VECTORBEGIN_in_vectordata278);
            if  (this->hasException())
            {
                goto rulevectordataEx;
            }


            {
                m_vectordata_stack.peek().variablecount = 0; 
            }


            // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:69:3: (cv1= NA |cv1= CONSTANTVALUE )
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NA:
                	{
                		alt3=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt3=2;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 3 );
                    ex->set_state( 0 );


                    goto rulevectordataEx;

                }

                switch (alt3)
                {
            	case 1:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:69:4: cv1= NA
            	    {
            	        cv1 =  this->matchToken(NA, &FOLLOW_NA_in_vectordata287);
            	        if  (this->hasException())
            	        {
            	            goto rulevectordataEx;
            	        }


            	        {
            	             retval.NAlocations
            	            .insert(m_vectordata_stack.peek().variablecount); 
            	            			
            	            retval.value
            	            .push_back(0); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:72:6: cv1= CONSTANTVALUE
            	    {
            	        cv1 =  this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_vectordata302);
            	        if  (this->hasException())
            	        {
            	            goto rulevectordataEx;
            	        }


            	        {
            	            retval.value
            	            .push_back(::atof((cv1->getText()).c_str())); 
            	        }


            	    }
            	    break;

                }
            }

            // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:74:2: ( COMMA (cv2= NA |cv2= CONSTANTVALUE ) )*

            for (;;)
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:74:3: COMMA (cv2= NA |cv2= CONSTANTVALUE )
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_vectordata315);
            	        if  (this->hasException())
            	        {
            	            goto rulevectordataEx;
            	        }


            	        {
            	            m_vectordata_stack.peek().variablecount++; 
            	        }


            	        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:75:3: (cv2= NA |cv2= CONSTANTVALUE )
            	        {
            	            int alt4=2;
            	            switch ( this->LA(1) )
            	            {
            	            case NA:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;
            	            case CONSTANTVALUE:
            	            	{
            	            		alt4=2;
            	            	}
            	                break;

            	            default:
            	                ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 4 );
            	                ex->set_state( 0 );


            	                goto rulevectordataEx;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:75:4: cv2= NA
            	        	    {
            	        	        cv2 =  this->matchToken(NA, &FOLLOW_NA_in_vectordata325);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulevectordataEx;
            	        	        }


            	        	        {
            	        	             retval.NAlocations
            	        	            .insert(m_vectordata_stack.peek().variablecount); 
            	        	            			 
            	        	            retval.value
            	        	            .push_back(0); 
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:78:5: cv2= CONSTANTVALUE
            	        	    {
            	        	        cv2 =  this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_vectordata340);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulevectordataEx;
            	        	        }


            	        	        {
            	        	            retval.value
            	        	            .push_back(::atof((cv2->getText()).c_str())); 
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_vectordata354);
            if  (this->hasException())
            {
                goto rulevectordataEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevectordataEx; /* Prevent compiler warnings */
    rulevectordataEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_vectordata_stack.pop(); 

    return retval;
}
/* $ANTLR end vectordata */

/**
 * $ANTLR start scalar
 * /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:84:1: scalar returns [std::string nodename, double value] : NODENAME EQUALTO (cv1= NA |cv1= CONSTANTVALUE ) ;
 */
BUGSDataParser_scalar_return
BUGSDataParser::scalar()
{
    BUGSDataParser_scalar_return retval(this);


    const CommonTokenType*    cv1;
    const CommonTokenType*    NODENAME7;

    /* Initialize rule variables
     */

    cv1       = NULL;
    NODENAME7       = NULL;
    retval.call_start_placeholder(); 



 
    {
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:85:2: ( NODENAME EQUALTO (cv1= NA |cv1= CONSTANTVALUE ) )
        // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:85:4: NODENAME EQUALTO (cv1= NA |cv1= CONSTANTVALUE )
        {
            NODENAME7 =  this->matchToken(NODENAME, &FOLLOW_NODENAME_in_scalar371);
            if  (this->hasException())
            {
                goto rulescalarEx;
            }


             this->matchToken(EQUALTO, &FOLLOW_EQUALTO_in_scalar373);
            if  (this->hasException())
            {
                goto rulescalarEx;
            }


            // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:86:3: (cv1= NA |cv1= CONSTANTVALUE )
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case NA:
                	{
                		alt6=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSDataParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto rulescalarEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:86:4: cv1= NA
            	    {
            	        cv1 =  this->matchToken(NA, &FOLLOW_NA_in_scalar381);
            	        if  (this->hasException())
            	        {
            	            goto rulescalarEx;
            	        }


            	        {
            	            std::cout << " Scalars cannot have NA as value" << std::endl; assert(false);
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/hazygroup/trunk/elementary/0.3/Elementary0.3/ui2/bugs_parser_db/antlrparser/BUGSData.g:87:5: cv1= CONSTANTVALUE
            	    {
            	        cv1 =  this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_scalar391);
            	        if  (this->hasException())
            	        {
            	            goto rulescalarEx;
            	        }


            	        {
            	            retval.nodename= (NODENAME7->getText());
            	             retval.value=::atof((cv1->getText()).c_str());

            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulescalarEx; /* Prevent compiler warnings */
    rulescalarEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end scalar */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
